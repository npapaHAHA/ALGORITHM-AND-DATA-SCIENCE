#include <iostream>#include <vector>#include <algorithm>#include <cmath>#include <iomanip>#include <cstdlib>#include <ctime>using namespace std;vector<int> p;int dsu_get(int v) {    if (v == p[v]) return v;    return p[v] = dsu_get(p[v]);}void dsu_unite(int a, int b) {    a = dsu_get(a);    b = dsu_get(b);    if (rand() & 1) swap(a, b);    if (a != b) p[a] = b;}int main() {    ios::sync_with_stdio(false);    cin.tie(nullptr);    srand(time(0));        int n;    cin >> n;        vector<pair<int, int>> cities(n+1);    for (int i = 1; i <= n; ++i) {        cin >> cities[i].first >> cities[i].second;    }    vector<pair<double, pair<int, int>>> edges;    for (int i = 1; i <= n; ++i) {        for (int j = i+1; j <= n; ++j) {            int dx = cities[i].first - cities[j].first;            int dy = cities[i].second - cities[j].second;            double dist_sq = dx*dx + dy*dy;            edges.push_back({dist_sq, {i, j}});        }    }    sort(edges.begin(), edges.end());    p.resize(n+1);    for (int i = 1; i <= n; ++i) {        p[i] = i;    }    vector<pair<int, int>> mst_edges;    double total_length = 0.0;    for (const auto& edge : edges) {        double dist_sq = edge.first;        int u = edge.second.first;        int v = edge.second.second;                if (dsu_get(u) != dsu_get(v)) {            dsu_unite(u, v);            mst_edges.push_back({u, v});            total_length += sqrt(dist_sq);        }                if (mst_edges.size() == static_cast<size_t>(n-1)) {            break;        }    }    cout << fixed << setprecision(6) << total_length << endl;    cout << mst_edges.size() << endl;    for (const auto& e : mst_edges) {        cout << e.first << " " << e.second << endl;    }    return 0;}